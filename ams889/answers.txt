Assignment 4

1. The author uses modules (modular programming), the single responsibility priciple for classes and cohesion. 
The modules each serve a different purpose, data.py being used to parse the underlying game data file, game.py to keep track of the state of the game (save, not saved, etc) and other modules to fill different roles.
The author uses many classes (especially in the model.py file) such as the Move class in model.py line 3 which allows the user to move in the game, class Object (model.py line 103) which establishes objects such as grates and keys and class Game (game.py line 19) which serves as the state of the game. Each of these classes has only one responsibility. Although the class Game is very large in terms of lines, it serves one responsibility (establish the state of the game at a given time).
Cohesion is used to explain how well the methods and class variables fit together as a "logical whole" ("Clean Code", Martin, 140). As the classes are small to begin with, it is easier to keep cohesion at a high level. For example, class Message(model.py line 145) has a single instance variable, "text", and it's lone method __str__ manpulates it. This means the class is technically maximally cohesive, although this is a very rare situation. The majority of classes in these modules are highly cohesive.

2. The author uses meaningful names, such as the function is_dark in the Room class (model.py line 79) which clearly will determine if a room is dark or light. Additionally, load_advent_dat (play.py line 3) loads the adventure data from the data.py file so the method is definitely named well. Two functions that appear to be named poorly (non-meaningful names) are the start2 function (game.py 130) and the loop function (adventure.py line 19). Start2 has to be defined underneath using a comment which states why it is a second start. Calling it InstructStart would probably be wiser. Additionally, loop as a name of a function only tells you what the process of the function is anticipated to be, not the context or why we want to loop.

3. Many of the functions in the program serve one purpose. The majority of the methods under the Object class (model.py line 103) do one thing; is_at (line 127) determines the location, carry (line 130) establishes if the object is being carried and subsequent functions determine if the object has been dropped or destroyed.
One function that appears to do several things is the Parse function (data.py line 198) which loops through sections parsing data as well as deleting an object, creating an identifier and then finally returning the end result. Additionally, Start2 (game.py line 130) displays the instructions and describes the location as well as establishes the instances of dwarves, pirates and treasures.

4. Side effects are code which is not implied by the name of a function (or its advertised purpose). One case of this is the Loop function (adventure.py line 19) is not only misnamed, it also contains more than just a loop. It not only uses a while not loop to continue the game progression, it also parses out arguments and uses an if statement to establish if the game is saved or restored. In order to be transparent, it's probably better to name this function something along the lines of "gameplayprogression" and perhaps separate the if statement from the while not (if it doesn't interfere with functionality.

5. Although it's not too many lines of code, in the Play and Resume functions (play.py lines 11 and 29) share the following lines of code used to initiate the gameplay in the prompt:
    global _game
    from game import Game
    from prompt import install_words
    install_words(_game)

Perhaps it would be reasonable to place these four lines in another function called "gameImports"

6. The program uses exception handling for the inputs. When a capital letter is used in place of a lowercase, an error message, such as "I DON'T KNOW THAT WORD.", pops up. Additionally, special characters are not even registered by the program. Placing "!@#^%" and submitting returns nothing. The only input I was able to provide to cause the program to crash was entering Ctrl + c.

7. One large class that consistently stands out is the Game class (game.py line 19). It claims (using comments) that it is used to keep track of the state of the game. It has responsibility over that as well as setting initial game values (such as maximum deaths and intervals used between specific error messages), start the game and control movement of both the user and dwarves.

8. The classes appear to be cohesive for the most part. Many of them only use built in variables (such as Object). The only class that appears to have rather low cohesion is, again, the Game class (game.py line 19) as it has many methods and many variables that don't appear in more than one or two.

9. The author comments code in various ways, some good practice and some not. For example, the author frequently uses informative comments to clarify a function with a single line comment such as "Advance random number generator so each input affects future" (game.py line 386) and defines the purpose of each module with a comment at the top, such as "Classes representing Adventure game components." (model.py line 1). These are very helpful in most cases as it gives a very quick note on the purpose of the function (if complicated) or module. Not all functions need to be explained by a comment as some names (in the meaningful names category of question 2) perfectly describe the functions purpose. Similarly, a class is described by comment in some places, for example the Move class (model.py line 3) which is clarified as "An entry in the travel table" (model.py line 4) so without reading too far into the code we know what to expect. Lastly, the author uses a lot of clarification comments, for example when defining the game class (game.py line 19) the author proceeds for roughly 20 lines to define instance variables and comments several with clarifications into why each instance variable is required.
Some poor commenting is done as well. First, there is a lot of mumbling around the start function (game.py line 114) where three comments essentially say the same thing: "# Game startup" (line 112), "Start the game." (line 115) and "Set things going." (line 124). Also another instance of mumbling occurs in the moveto function of the game class: "IF LOC.EQ.0 ?" (game.py line 179). This might be a TODO comment but the author does not specify so the programmer reading through the code wont understand the comment. Another example of bad commenting can be seen in the move_dwarves function in the game class when the author uses redundancy before running code to specify what action the dwarves took; the author comments "# Report what has happened."(game.py line 290) which is very clear from the code below. Lastly, there are instances of code commented out which is poor form and should be removed as version control can regulate previously used code that is vestigial to the current version; in the install_words function in the ReprTriggeredPhrase class (prompt.py line 5), we see a line of commented out code "# stack()[0] is this; stack()[1] is adventure.play(); so, stack()[2]"(prompt.py line 29).

10. The author uses several vertical formatting concepts to make the code more readable. There are many instances of vertical openness between concepts; taking a look at prompt.py, we see a blank line between every function defined in the ReprTriggeredPhrase class and we find an additional two spaces after the class before the next function (which serves a different functionality from the class) is defined. Additionally, in the Game class (game.py line 19) all the instance variables are defined at the top of the class which helps to understand the vertical flow of the class.

11. Initially, the test_command.py file failed as it was located in a subdirectory. Once copying the test files into the main assignment4 adventure directory, no test files threw an error, which signals that all the tests were passed.
For a test to pass the F.I.R.S.T. criteria, it must be fast, independent of other tests, repeatable, self-validating and be completed in a timely fashion.
As the tests took less than a second to run on my machine, they certainly pass the first (F) criteria.
Looking into the test codes, it appears that no test module requires another to run (nothing is imported from one test to another). This confirms that the second (I) criteria is met.
Although I only ran the tests on the virtualbox environment, they don't appear to have anything embedded which would cause an issue in any other environment, therefore the third (R) criteria is met.
Looking at the codes for each test, there is no output that would require manual intervention to confirm a pass or fail of the test. As long as each test does not return an error, they have passed and thus the tests meet the fourth criteria (S).
Lastly, judging by the log at the bottom of the readme file, the tests were only 100% completed over two weeks after the first public release. Tests should be completed before releasing the code to production so in my opinion the fifth criteria is not met (T).
