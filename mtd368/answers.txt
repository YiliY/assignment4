1. The structure of the program uses the concept of a module to separate the concerns of the program. Namely, the Adventure module allows us to actually play the game and is what allow users to interact with the program. This module imports aspects from the modules to allow the entire program to broken down into logical parts that each reflect the responsibility it handles. The second technique used is to break up the structure inside each module into logical classes that handle both the structural elements and behavior of a given component. The best example of this is in the model.py module.  In here we have the various components of the game defined in terms of the attributes each has and the behavior each exhibits via the functions defined. Lastly, the author adheres to the approach of only have a class handle one responsibility, which is most evident in the model.py module, because the classes in that module tend to be very distinct in the sole purpose they serve. 
2. I think the author has generally used meaningful names, but at certain points fails to meet the requirement of having names be fully pronounceable and describe the component’s purpose. Examples of good naming are in the model.py module. Each item in here is clearly identified by it’s Class Name and then the variables inside each are clear.  For example, the Class Hint is very clear what it does and the attributes truns_needed and turn_counter are very clear. I would say an example of where the author’s naming could have been more clear is in the game.py module. The function start2 at line 126 could have been more descriptive, for example by calling itself, “re-start”, or something along the lines that more clearly indicates the purpose of the function.  Another example of poor naming is the function on line 19 of the adventure.py module. I understand it is a loop, but it isn’t clear what it is looping through. 
3. The functions used in the code do not always do one thing. 
Functions that do more than one thing: 
  game.py line 629 — do_motion — further down in this function the author is setting the values of troll.prop, so this function could probably be simplified down. 
  game.py line 384 — move_dwarves — because it not only moves the dwarf, but also count the number of dwarf attacks (line 210) 
Functions that do one thing: 
  model.py line 173 — start_at — only handles the starting position of the dwarf. 
  model.py line 127 — is_at — only returns a single value. 
4. A great example of a side effect in a function that does more than one thing is in the move_dwarves function, because it sets the dwarf_count = dwarf_attacks = knife_wounds = 0, to start, but then updates it at (line 246) for example, so we think this function should just be moving the dwarf around, but it is also handling the setting of the knife_wounds as well. 
5. A great example of where code is repeated and could be broken down into a single function is from line 464 to 488 in the game.py module.  Specifically, I think this is the case because I would just want to define a single function that takes in the lamp_turns parameter and returns a value to the do_command, simplifying the do_command function. 
6. Yes, the program uses exception handling, for example line 43 of the adventure.py module.  I tried getting the program to crash, by manipulating the t_suspend function, but was unsuccessful. 
7. Yes, the class Game in line 19 of game.py is massive and should probably be broken down into more simple logical parts that have only a single responsibility.  This class does so many different functions from returning messages to counting turns, its seems like this could’ve been broken down into a couple separate classes.  
8. I think some of the classes are cohesive, but I would say for sure the class Room in the model.py module isn’t cohesive, because the methods don’t manipulate  a majority of the large set of attributes defined for the class. Another example of a class that isn’t cohesive would be the Hint Class on line 152. It has a number of attributes defined, but they are manipulated via methods in the class. 
9. The author attempts to comment the code so that the variable names and other more difficult to understand pieces are more clear.  For example, in game.py lines 21 to 36, the author attempts to explain the meaning of each variable, but they could have made the names longer and more explanatory, thus negating the need of the comments.  An example of bad comments are in the test_walks.py module lines 9 and 10 because these are commented out code that should just be removed.  A good example of comments are in the test_commands module because reading through the commands that are inserted is cryptic without some explanation of what the user is responding to. 
10. A great example of vertical spacing is in the test_commands module.  Lines 7-11 are a logical group because that is the setup of the game.  Following that are two more logical groups one is for intransitive command and the other is for transitive commands, so they are logically separate and the vertical space separates them nicely. 
11. I don’t think the test meet the FIRST criteria because they don’t do any self-validation.  I don’t receive any feedback when I run them confirm whether the tests are validated as passing or failing. 