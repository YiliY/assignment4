Name: Benjamin Jakubowski
Net ID: BUJ201

Assignment 4

1. The first main technique the author used to structure the program is building a package. The entire program is encapsulated within the package (with all modules in a directory containing an __init__.py file).
The second technique is dividing the programming into a number of modules, each addressing a separate concern. For example:
1. data.py parses advent.dat (the text file containing game data), constructing objects (rooms, messages, hints, objects, etc.) from each section in this data file (note the data file is broken into 12 sections, separated by -1\n).
2. model.py creates abstract data types (classes), including move, room, word, object, message, hint, and dwarf (with subclass pirate).
3. adventure.py imports and calls other necessary modules (and external packages) so the game can be initiated from the command line.
4. game.py handles game mechanics including movement (of the player, dwarves and pirates) and the central do_command function (which ultimately implements commands input in the prompt by the player), death and callback, hints, and end of game (saving, scoring, and exiting game).
The last technique (alluded to previously) is the use of classes, including move, room, word, object, message, hint, and dwarf. These classes encapsulate state information (attributes) for each instance (i.e. each dwarf has a Boolean attribute self.has_seen_adventurer) as well as behavior (for example, objects can be dropped in a room with the self.drop() method). 

2. The author has used many meaningful names. For example, attributes of the class room (defined in model.py, line 38) are clearly meaningful and their meanings can be easily inferred. For example, long_description is the long description of a room while short_description is the shortened description (the long descriptions are only used in the prompt a limited number of times, then the short description is used by default). is_forbidden_to_pirate probably specifies whether or not a pirate can randomly enter a room. is_light probably specifies if the room is light (if it is dark, the lamp object would probably be necessary to light the room). These variable names are descriptive and human readable. 
On the other hand, there are a number of names that are not meaningful. For example, beginning on data.py line 59, the author defines 12 helper functions to parse the advent.dat file. These function are called section1, section2, …, section12. To determine the meaning of these functions, I had to open up advent.dat, read through the data, and notice that there are 12 sections (separated by -1\n, with the section number given in the first new line after this separator). These functions should have been given longer, more meaningful names (i.e. parse_section1_rooms instead of just section1.

3. Some functions in the code do more than one thing. For example, in game.py  line 131, the docstring for function start2 (a method of Game objects) says “Display instructions if the user wants them.” The function does this with code on lines 132-135, but then proceeds to also set the location attributes, place the dwarves in rooms 19, 27, 33, 44, and 64, place the pirate in the final room (which I assume contains a treasure chest), and count the number of treasures remaining (not found). As such, this function does much more than “display instructions if the user wants them”. Another example is the function move_to defined in game.py on line 153.  Instead of moving the player (by describing the new location) this function starts by evaluating many conditions (i.e. if self.is_closing and newloc.is_aboveground, or dwarf_blocking_the_way). 
A function that clearly does one thing is say_ok_and_finish (in game.py, on line 376). This function does exactly what it says it does- it calls self.write_message(54), presumably to say ok. Then it calls self.finish_turn() to finish the turn.

4. One example of a function that causes a side effect is describe_location in game.py on line 323. This function first evaluates if you could_fall. If so, and a random number is generated less than .35, it calls self.die_here(). This is clearly a side effect- the function is defined as describe_location, not describe_location_and_maybe_kill_player. A similar side effect is found in move_dwarves (on line 188). Depending on the number of dwarves that attack, and the number that inflict a knife_wound (a random variable defined on line 245), you may sustain a fatal number of knife_wounds. If so, line 318 produces the side effect self.die().

5. A number of the i_<verb> functions defined in game.py are repetitive and could be refactored into a single function. For example, the functions i_eat on line 1196 and i_drink are very repetitive. In essence, these two functions (and several other i_<verb> functions evaluated a simple or compound condition (for example, in i_eat the condition self.is_here(self.food)). If the condition is met, i_<verb> calls the corresponding t_<verb> function with the default object (for example, self.food). If not, it calls self.ask_verb_what(verb). These repetitive i_<verb> functions could be refactored into a single function that takes <verb> as an argument.

6. The program does not seem to use python’s built-in exception handling. When game.py is searched for “throw”, “try”, or “except”, the only pythonic use of these terms is try on line 1554 (which is followed by finally). This exception handling controls game saving, not input from the prompt. In adventure.py, throw and except are used, but only trivially (to check that the module is called directly (i.e. __name__ = “__main__”)).
Instead of using built-in exception handling, the program handles invalid input through if statements and function calls. First adventure.py’s loop function (on line 37) takes raw_input as “line”. It then converts the raw_input into a list of non-overlapping alphanumeric strings (with re.finall(r’\w+’,line)). If this list is not empty, it then passes it as the argument to self.do_command.
The self.do_command then passes the words as arguments to self._do_command, which checks if the words were called in response to a yes/no question. If so, it checks that the raw input was either yes, no, y, or n (using the dictionary YESNO_ANSWERS on line 17). If a yes/no input was expected and not received, the program prompts the user to answer the question (line 440), then re-enters adventure.py’s loop (line 37).
If a yes/no question was not asked, it updates a number of state variables (such as the game turn counter – line 453), writes messages as need, then dispatches the command via self.dispatch_command. This command evaluates a number of conditions for input words. First, it checks that either 1 or 2 words were input by the user. If not, it calls self.dont_understand() on line 514, since the user has input too many or too few words.
If one or two words were entered, it next checks if the first word was save. If so, it calls self.t_suspend() on line 510 to save the game. If the first word was not save, the input words are then check against the game’s vocabulary (line 512), so that only valid words are passed on to the rest of the dispatch_command function. Again, if no valid words are found, it calls the self.dont_understand() function.
This approach to exception handling is used throughout the program- instead using python’s built-in exception handling, the program use a series of if statements and function calls, including self.dont_understand(),i_see_no() defined on line 462 (which handles input of valid object names in invalid contexts), and ask_verb_what on line 1384 (which handles input of transitive verbs given without an object, i.e. throw instead of throw knife) to handle invalid input. Through comprehensive use of these if statements and functions, no input is found that abnormally terminates the game.

7. Most of the classes defined in model.py have responsibility for just one piece of functionality. However, the class Game (a subclass of the superclass Data) has responsibility for essentially all the functionality in the game itself. Instead, Game could be broken into several subclasses. 

8. The classes are not all cohesive. For example, the class Object has an attribute self.contents that only applies to the bottle- perhaps it would be more appropriate to break this class into a subclass, such as Container(Object), with instances “bottle” and “cage”. Another, more significant example of a class that isn’t cohesive is Word. This class has an attribute kind, which takes the value ‘travel’, ‘noun’,’verb’, or ‘snappy_comeback’ (data.pyline 119). If these had been broken out as subclasses, the author may have been able to write subclass methods that allow for more concise implementations of the i_verb and t_verb functions on lines 834-1564  in game.py.
Finally, while these classes have relatively low cohesion, it is worth noting that the class Dwarf has higher cohesion. This class encapsulates most of the methods describing dwarf behavior, and all the methods and attributes are used by each instance of this class. 

9.Looking at the largest module (game.py), the author uses comments in a couple ways. First, he/she intentionally uses comments to indicate line numbers in the original advent.for code. Second, he/she often use comments to translate index values to human readable statements. For example, on line 175, the author translates self.write_message(2) with the comment “# dwarf is blocking the way”. Similarly, on line 730 the author translates places[0] to “# “the other side of the bridge””. Finally, the author seems to provide comments to explain how the code translates back to game mechanics. For example, on line 241, the comment “# A dwarf cannot walk and attack at the same time” explain the if statement “if dwarf.room is dwarf.old_room”, and similarly on line 1267 the comment “# 1/3rd chance that throwing the axe kills a dwarf” explain the following code if self.choice((True, False, False)).
One example of a good comment is the extended comment on lines 218 to 222. This comment explains why it is important to sort the locations, so that random memory addressing doesn’t make it impossible to deterministically test the game by setting the seed.
There are several examples of poor comments in the code. One is on line 1576- the comment #” Reinstate the random number generator” precedes the code game.random_generator = random.Random(). This comment is redundant, since it is obvious that’s the effect of this code. Another example of a bad comment is on line 785- “# do water and oil thing”. While this comment may have had meaning to the author, it is so opaque to an outside reader that it is essentially meaningless noise.

10. There are several examples of effective vertical formatting. One clear example is in the function compute_score on line 1649 of game.py. This function computes the maximum possible score as well as the players score. The score is the sum of points earned over several categories (as examples, the number of hints used or the amount of treasure collected). To make this computation clear, the author has left vertical white space between different score components and used a consistent format (line 1: maxscore += value \n line 2: if <condition>: \n line 3: score += value).

11.


